---
layout: post
title: 《javascript设计模式》1-4章总结
date: 2018-08-26
tag: javascript
---

目前看完了前九章，做一个简单的复习。

1-3章：设计模式大量使用了this,call,apply,闭包,高阶函数，所以前三章主要介绍了这些。特别是对闭包的说明，让我对闭包的地位有了一个全新的认识。设计模式使用js来实现时会使用作为一等对象的函数或是闭包。

4章：分别讲了单例模式。（复习之前都有些印象诶，这次学的效果不错，nice。）

第4章单例模式：惰性单例、代理模式实现单例。

## 第一章

### 鸭子类型

动态语言建立在`鸭子类型`的概念上。鸭子类型的通俗说法是：“如果它走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。”

在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，可以轻松实现动态类型语言中的一个原则：**面向接口编程，而不是面向实现编程**。

### 多态

多态的实际含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息时，这些对象会根据这个消息分别给出不同的反馈。

**多态对根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句**

javascript中的多态性是指对象的多态性，`做什么`和`怎么做`是可以分开的。`做什么`写到一个函数中，是稳定的。`怎么做`写到各个对象中，成为对象的属性方法。

比如下面这个列子：

```js
var googleMap = {
  show: function() {
    console.log('开始渲染谷歌地图');
  }
};

var baduMap = {
  show: function() {
    console.log('开始渲染百度地图');
  }
};

var renderMap = function(map) {
  if (map.show instanceof Function) {
    map.show();
  }
};

renderMap(googleMap);
renderMap(baiduMap);
```

### 封装

封装的目的是将信息隐藏。

1. 封装数据

利用闭包实现数据封装。

```js
var myObject = (function() {
  var _name = 'sven';
  return {
    getName: function() {
      return _name;
    }
  };
})();

console.log(myObject.getName()); // sven
console.log(myObject._name); // undefined
```

2. 封装实现

封装使得对象之间的耦合变得松散，对象之间只通过暴露的api接口来通信。当我们修改一个对象时，可以随意的修改功能，只要对外的接口没有变化就不会影响到程序的其他功能。

### 原型编程的基本原则

1. 所有的数据都是对象
2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它
3. 对象会记住它自己的原型
4. 如果对象无法相应某个请求，它会把这个请求委托给它自己的原型

### 两种创建对象的方式的比较

1. 在当前的javascript引擎下，通过Object.create来创建对象的效率并不高，通常比通过构造函数创建的对象要慢；
2. 通过设置构造器的prototype来实现原型继承的时候，除了根对象Object.prototype本身之外，任何对象都会有一个原型。而通过Object.create(null)可以创建出没有原型的对象。

## 第2章

### this

下面的这样简写会报错：

```js
var getId = document.getElementById;
getId('div1');
```
因为多数浏览器引擎的`document.getElementById`方法的内部实现中需要用到`this`，这个`this`需要指向`document`。当`getElementById`方法作为`document`对象的属性被调用的时候，方法内部的`this`确实是指向`document`的。但是，当用`getId`来引用`document.getElementByid`之后，再调用`getId`时，就成了普通函数的调用，函数内部的`this`指向了`window`，而不是原来的`document`。

解决办法：

```js
document.getElementById = (function(func) {
  return funtcion() {
    return func.apply(document.argument);
  }
})(document.getElementById);

var getId = Document.getElementById;
var div = getId('div1');
```

或者

```js
document.getElementById = document.getElementById.bind(document);
```

### call和apply

能熟练运用这两个方法，是我们真正成为一名javascript程序员的重要一步。

当使用call或者apply的时候，如果我们传入的第一个参数是null，函数体内的this会指向默认的宿主对象，在浏览器中则是window。

如果在严格模式下，函数体内的this还是为null。

有时候我们使用call、
或者apply的目的在于接通其他兑现的方法，那么我们可以传入null来代替某个具体的对象：

```js
math.max.apply(null, [1, 2, 3, 4, 5]);
```

**用途**

1. 改变this的指向
2. Function.prototype.bind

手动实现一个增强版的`bind`方法：

```js
Function.prototype.bind = function() {
  var self = this, // 此处会保存原函数，是调用bind的函数
      context = [].shift.call(arguments), // 获取第一个参数，即需要绑定的上下文
      args = [].slice.call(arguments); // 上面的shift会改变arguments，剩余的参数组成数组
  
  return function() {
    return self.apply(context, [].concat.call(args, [].slice.call(arguments)));
  };
};

var obj = {
  name: 'sven'
};

var func = function(a, b, c, d) {
  alert(this.name);
  alert([a, b, c, d]);
}.bind(obj, 1, 2);
func(3, 4);
```

3. 借用其他对象的方法

    1. 借用构造函数

        ```js
          var A = function(name) {
            this.name = name;
          };

          var B = function() {
            A.apply(this, arguments);
          }

          B.prototype.getName = function() {
            return this.name;
          }

          var b = new B('sven');
          console.log(b.getName()); // sven
        ```
    
    2. 借用数组的方法操纵类数组

      **借用数组的方法需要满足下面两个条件：**

      1. 对象本身要可以存取属性；（数值类型就不可以）
      2. 对象的`length`属性可以读写。（函数的length属性是传入的形参的个数，就是个只读属性，所以函数就无法借用数组的方法）。

      ```js
      (function() {
        Array.prototype.push.call(arguments, 3);
        console.log(arguments);
      })(1, 2);
      ```

      - 把arguments转成真正的数组时，借用`Array.prototype.slice`;
      - 截取arguments列表中的头一个元素，借用`Array.prototype.shift`;
      - 向arguments中插入一个新的元素时，借用`Array.prototype.push`。

      V8引擎关于`Array.prototype.push`的实现：
      ```js
      function ArrayPush() {
        var n = To_UNIT32(this.length); // 被push的对象的length

        var m = %_ArgumentsLength(); // push 的参数个数

        for (var i = 0; i < m; i++) {
          this[i + n] = %_Arguments(i); // 复制元素,对象本身可以存取属性


        }
        this.length = n + m ; // 修正length属性的值，对象的length属性可以读写

        return this.length;
      }
      ```

      下面这段代码改变了我对对象的认识，它竟然能在chrome中执行！！！明明对象没有`length`属性，但是对普通对象调用`Array.prototype.push`方法就会对这个对象添加一个`length`属性，并按序号添加键值对，俨然就是一个类数组。

      ```js
      var a = {};
      Array.prototype.push.call(a, 'first');
      console.log(a); // {0: 'first', length: 1}
      ```

## 第3章

### 闭包

1. 封装变量&提炼函数

**如果在一个大函数中有一些代码块能够独立出来，我们常常会把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也能起到注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把它们用闭包封闭起来。**

```js
var mult = (function() {
  var cache = {};
  var calculate = function() {
    var a = 1;
    for (var i = 0; l = arguments.length; i < l; i++) {
      a = a * arguments[i];
    }
    return a;
  };

  return function() {
    var args = Array.prototype.join.call(arguments, ',');
    if (args in cache) {
      return cache[args];
    }
    return cache[args] = calculate.apply(null, arguments);
  };
})();

mult(1, 2, 3);
```

上面这段代码，有两个地方是自己平时不会这样写的，走势在最后一行：

  1. `return cache[args] = calculate.apply(null, arguments)`返回值在此处李永乐赋值表达式的返回结果；
  2. `calculate.apply(null, arguments)`中`calculate`的调用使用了`apply`，如果用普通的函数传参调用会导致上面`calculate`函数中的`arguments.length=1`。所以要使用`apply`调用。

2. 延续局部变量的寿命

### 闭包和面向对象的设计

对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。**通常用面向对象思想能实现的功能，用闭包也能实现。**卧槽！从没想过闭包的地位竟然这么高！！！！！

使用闭包实现一段代码：

```js
var extent = function() {
  var value = 0;
  return {
    call: function() {
      value++;
      console.log(value);
    }
  };
};

var extent = extent();
extent.call();
extent.call();
extent.call();
```

使用面向对象实现相同的结果：

```js
var extent = {
  value: 0,
  call: function() {
    this.value++;
    console.log(this.value);
  }
};
extent.call();
extent.call();
extent.call();

// 或者

var Extent = function() {
  this.value = 0;
};

Extent.prototype.call = function() {
  this.value++;
  console.log(this.value);
};

var extent = new Extent;
extent.call();
extent.call();
extent.call();
```

### 闭包与内存管理

如果将来要回收这些变量，可以手动把这些变量设为null。

循环引用导致了内存泄露，为了解决这个问题，只需要把循环引用中的变量设为null即可。

### 高阶函数-函数作为参数

**把函数作为参数传递，把一部分容易变化的业务逻辑抽离出来，放在函数参数中，这样以来可以分离业务代码中变化与不变的部分。** —— 另一种实现代码分离的方法，之前说过的多态可以做到这点。

1. 回调函数
2. Array.prototype.sort

### 高阶函数-函数作为返回值输出

1. 单例模式

```js
var getSingle = function(fn) {
  var ret;
  return function() {
    return ret || (ret = fn.apply(this, arguments));
  };
};

var getScript = getSingle(function() {
  return document.createElement('script');
});

var script1 = getScript();
var script2 = getScript();

console.log(script1 === script2);
```

2. 函数currying

**`currying`又称`部分求值`**。一个currying的函数首先会接受一些参数，接受了这些参数后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。

比如下面的例子：

```js
var currying = function(fn) {
  var args = [];
  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args);
    } else {
      [].push.apply(args, arguments);
      return arguments.callee // 这个callee不再推荐使用了
    }
  }
};

var cost = (function() {
  var money = 0;
  return function() {
    for (var i =0, l =arguments.length; i < l; i++) {
      money += arguments[i];
    }
  }
})();

var cost = currying(cost);

cost(100); // 未真正求值
cost(200); // 未真正求值
cost(300); // 未真正求值

console.log(cost()); // 求值并输出结果
```

2. uncurrying

在javascript中，当我们调用对象的某个方法时，其实我们不用去关心这个对象原本是否被设计为拥有这个方法，这是动态语言的特点，也就是常说的鸭子类型的思想。

`Array.prototype`上的方法原本只能用来操作array对象。但用call和apply可以把任意对象当作`this`传入某个方法，这样一来，方法中用到`this`的地方就不再局限于原来规定的对象，而是加以泛化并得到更广的适用性。

**`uncurrying`就是把泛化`this`的过程提取出来。**

下面的代码是实现`uncurrying`的方法之一：

```js
Function.prototype.uncurrying = function() {
  var self = this;
  return function() {
    var obj = Array.prototype.shift.call(arguments);
    return self.apply(obj, arguments);
  };
};
```

使用上面的代码创建一个通用的`push`函数。这个`push`函数的作用和`Array.prototype.push`的作用一样，但嗲用更简洁，意图明显。

```js
var push = Array.prototype.push.uncurrying();
(function() {
  push(arguments, 4);
  console.log(arguments);
})(1, 2, 3);
```

下面的代码一次性地把`Array.prototype`上的方法复制到array对象上，同样这些方法可以操作的对象也不仅仅是array对象：

下面这个`for`循环的写法，自己从来没有这样用过诶，条件判断的地方用的是`fn = ary[i++]`，这种写法感觉是利用了复制表达式返回结果的特性，当`ary[i++]`为`undefined`的时候，这个赋值表达式`fn = ary[i++]`就会返回`undefined`，此处的条件判断为假，即停止循环。这是看到的本书中遇到的第二个使用赋值表达式的地方，上一个是直接利用赋值表达式给一个便利那个赋值的同时`return`结果。

```js
for (var i = 0, fn, ary = ['push', 'shift', 'forEach']; fn = ary[i++]; ) {
  Array[fn] = Array.prototype[fn].uncurrying();
};

var obj = {
  length: 3,
  0: 1,
  1: 2,
  3: 3
};

Array.push(obj, 4);
console.log(obj.length); // 输出4

var first = Array.shift(obj);
console.log(first); // 输出1
console.log(obj); // 输出{0：2, 1： 3, 2： 4, length: 3}
```
**uncurrying的另一种实现方式：**

**看不懂！！！！！还是看不懂！！！！！仅记录在此**

```js
Function.prototype.uncurrying = functino() {
  var self = this;
  return function() {
    return Function.prototype.call.apply(self, arguments);
  }
};
```

3. 函数节流

**使用场景**

- `window.onsize`事件。给`window`对象绑定了`resize`事件，当浏览器窗口大小被拖动而改变的时候，这个事件触发的频率非常高。如果我们在`window.onresize`事件函数里有一些和`DOM`节点相关的操作，而跟`DOM`节点相关的操作往往非常消耗性能，这时候浏览器可能会吃不消而造成卡顿现象。

- `mousemove`事件。如果给一个`div`节点绑定了拖拽事件`主要是mousemove`，当`div`节点被拖动的时候，也会频繁地处罚该拖拽事件函数。

**函数节流原理**
使用`setTimeout`忽略掉一些事件请求。

**代码**

```js
var throttole = function(fn, interval) {
  var _self = fn,
      timer,
      firstTime = true;
  return function() {
    var args = arguments,
        _me = this;
    
    if (firstTime) {
      _self.apply(_me, args);
      return firstTime = false;
    }

    if (timer) {
      return false;
    }

    timer = setTimeout(function() {
      clearTimeout(timer);
      timer = null;
      _self.apply(_me, args);
    }, interval || 500);
  };
};

window.onresize = throttle(function() {
  console.log(1);
}, 500);
```

上面这段代码中：

```js
var args = arguments,
    _me = this;

if (firstTime) {
  _self.apply(_me, args);
}
```

发现很过工具类的函数都喜欢这样写诶。用一个变量保存当前函数的`this`，感觉这么做是为了保存this的正确指向。然后使用`apply`函数调用函数，传入`this`和参数。

4. 分时函数

函数节流的本质是限制函数被频繁调用。

分时函数解决的是段时间内往页面中大量添加DOM节点的问题。这个问题会给浏览器带来很大的负担，导致的结果就是浏览器的卡顿或是假死。

下面这段代码是不采用分时函数的普通写法，这种写法就会导致浏览器的卡顿：

```js
var ary = [];

for (var i = 1; i <= 1000; i++) {
  ary.push(i);
}

var renderFriendList = function(data) {
  for (var i = 0, l = data.length; i < l; i++) {
    var div = document.createElement('div');
    div.innerHTML = i;
    document.body.appendChild(div);
  }
};

renderFriendList(ary);
```

解决上述问题的方法之一就是让创建节点的工作分批进行，日如把1秒钟创建的1000个节点，改为每隔200毫秒创建8个节点。

下面是一段分时函数的示例代码：

```js
var timeChunk = function(ary, fn, count) {
  var obj,
      t;
  var len = ary.length;
  var piece = function() {
    for (var i = 0; i < Math.min(count || 1, ary.length); i++) {
      var obj = ary.shift();
      fn(obj);
    }
  };

  return function() {
    t = setInterval(function() {
      if (ary.length === 0) {
        return clearInterval(t);
      }
      piece();
    }, 200);
  };
};
```

使用下面这段代码进行测试：

```js
var ary = [];
for (var i = 1; i <= 1000; i++) {
  ary.push(i);
}
var renderFriendList = timeChunk(ary, function(n) {
  var div = document.createElement('div');
  div.innerHTML = n;
  document.body.appendChild(div);
}, 8);

renderFriendList();
```

5. 惰性函数加载

这个地方有必要再看下原书

addEvent函数依然被声明为一个普通函数，在函数里依然有一些分支判断。但是在第一次进入条件分支之后，在函数内部会重写这个函数，重写之后的函数就是我们期望的addEvent函数，在下一次进入addEvent函数的时候，addEvent函数里不会再存在条件分支语句。

代码如下，下面的addEvent代码在改变前是一个普通函数：

```js
var addEvent = function(elem, type, handler) {
  if (window.addEventListener) {
    addEvent = function(elem, type, handler) {
      elem.addEventListener(type, handler, false);
    }
  } else if (window.attachEvent) {
    addEvent = function(elem, type, handler) {
      elem.attachEvent('on' + tyoe, handler);
    }
  }
  addEvent(elem, type, handler); // 此处调用了已重写了的自己
}
```

---
**将不变的部分和变化的部分分开是每个设计模式的主题**
---
## 第4章 单例模式

单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

下面是一段创建单例的代码：

```js
var CreateDiv = (function() {
  var instance;
  var CreateDiv = function(html) {
    if (instance) {
      return instance;
    }
    this.html = html;
    this.init();
    return instance = this;
  }

  CreateDiv.prototype.init = function() {
    var div = document.createElement('div');
    div.innerHTML = this.html;
    document.body.appendChild(div);
  };

  return CreateDiv;
})();

```
上面这段代码要使用`new`来调用。

这种写法会增加程序的复杂度，不方便阅读，不符合`单一职责`。

用代理实现单例模式代码如下：

```js
var CreateDiv = function(html) {
  this.html = html;
  this.init();
};

CreateDiv.prototype.init = function() {
  var div = document.createElement('div');
  div.innerHTML = this.html;
  document.body.appendChild(div);
};

// 下面是代理类

var ProxySingletonCreateDiv = (function() {
  var instance;
  return function(html) {
    if (!instance) {
      instance = new CreateDiv(html);
    }
    return instance;
  }
})();

var a = new ProxySingletonCreateDiv('sven1');
var b = new ProxySingletonCreateDiv('sven2');

console.log(a === b);
```

### javascript中的单例模式

**全局变量不是单例模式，但在JavaScript开发中，我们经常会把全局变量当成单例来使用。**

避免全局污染的方法：

1. 使用命名空间；
2. 使用闭包封装。

### 惰性单例（书里说这种方式非常有用，手动五星×××××）

惰性单例是指在需要的时候才创建的对象实例。

**符合`单一职责原则`并且`可以用于创建不同对象`的惰性单例实现步骤：**

1. 封装管理单例的逻辑

```js
var getSingle = function(fn) {
  var result;
  return function() {
    return result || (result = fn.apply(this, arguments));
  };
};
```
2. 下面这段代码是创建对象的逻辑

```js
var createLoginLayer = function() {
  var div = document.createElement('div');
  div.innerHTML = '我是登录浮窗';
  div.style.display = 'none';
  document.body.appendChild(div);
  return div;
};
```

3. 下面这段代码把两个逻辑拼在一起

```js
var createSingleLoginLayer = getSingle(createLoginLayer);
document.getElementById('loginBtn').onclick = function() {
  var loginLayer = createSingleLoginLayer();
  loginLayer.style.display = 'block';
};

// 另一个例子，创建唯一的iframe用于动态加载第三方页面

var createSingleIframe = getSingle(function() {
  var iframe = document.createElement('iframe');
  document.body.appendChild(iframe);
  return iframe;
});

document.getElementById('loginBtn').onclick = function() {
  var loginLayer = createElement('iframe');
  loginLayer.src = 'http://baidu.com';
};
```

这种单例模式的用途远不止创建对象，比如我们通常在渲染完页面中的一个列表之后，接下来要给这个列表绑定click事件，如果是通过ajax动态往列表里追加数据，使用事件代理的前提下，click事件实际上只需要在第一次渲染列表的时候绑定一次，但是我们不想去判断当前是否是地刺渲染列表，单例的解决方法如下：

```js
var bindEvent = getSingle(function() {
  document.getElementById('div').onclick = function() {
    console.log('click');
  };
  return true;
});

var render = function() {
  console.log('开始渲染列表');
  bindEvent();
};

render();
render();
render();
```

