---
layout: post
title: http查漏补缺之一
date: 2018-07-18
tag: http
---

下文主要关于浏览器和代理缓存。


1. http缓存

    使用`Cache-Control`控制缓存，不同值之间使用逗号和空格分割。

    1. 强制确认缓存

        `Cache-Control: no-cache` ：每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。

        *MDN的页面请求头中都带有这个消息头，比如这个[页面](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)。*

    2. 缓存过期机制

        `Cache-Control: max-age=31536000`：max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。

        *比如这个[页面](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)的css文件*

        ![缓存过期时间](/images/http/1.png)
    
    3. 禁止进行缓存

        `Cache-Control: no-store`

    4. 缓存验证确认

        `Cache-Control: must-revalidate`

2. Expires

    Expires响应头包含日期/时间，即在此时间之后，响应过期。

    如果在`Cache-Control`相应头设置了 *max-age* 那么Expires头会被忽略。

3. 缓存新鲜度

    由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做缓存驱逐。

    服务器更新一个资源时，不可能直接通知客户端及其缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。

    驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个`If-None-Match`头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 `304 (Not Modified)`（该响应不会有带有实体信息），**则表示此资源副本是新鲜的**，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。

    见下图描述：

    ![缓存新鲜度](/images/http/HTTPStaleness.png)

4. 计算缓存寿命

    1. 当有比如`Cache-control: max-age=N的请求头`这种的特定头，相应的缓存的寿命就是N。

    2. 如果没有 `Cache-control`请求头，会去查看是否包含`Expires`属性，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。

    3. 如果既没有`Cache-control`， 也没有`Expires`，就会查找头里的`Last-Modified`信息。如果有，缓存的寿命就等于头里面Date的值减去Last-Modified的值除以10。