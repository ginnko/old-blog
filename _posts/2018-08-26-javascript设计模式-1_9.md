---
layout: post
title: 《javascript设计模式》1-9章总结
date: 2018-08-26
tag: javascript
---

目前看完了前九章，做一个简单的复习。

1-3章：设计模式大量使用了this,call,apply,闭包,高阶函数，所以前三章主要介绍了这些。特别是对闭包的说明，让我对闭包的地位有了一个全新的认识。设计模式使用js来实现时会使用作为一等对象的函数或是闭包。

4-9章：分别讲了单例模式、策略模式、代理模式、迭代器模式、发布-订阅模式以及命令模式。（复习之前都有些印象诶，这次学的效果不错，nice。）

## 第一章

### 鸭子类型

动态语言建立在`鸭子类型`的概念上。鸭子类型的通俗说法是：“如果它走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。”

在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，可以轻松实现动态类型语言中的一个原则：**面向接口编程，而不是面向实现编程**。

### 多态

多态的实际含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息时，这些对象会根据这个消息分别给出不同的反馈。

**多态对根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句**

javascript中的多态性是指对象的多态性，`做什么`和`怎么做`是可以分开的。`做什么`写到一个函数中，是稳定的。`怎么做`写到各个对象中，成为对象的属性方法。

比如下面这个列子：

```js
var googleMap = {
  show: function() {
    console.log('开始渲染谷歌地图');
  }
};

var baduMap = {
  show: function() {
    console.log('开始渲染百度地图');
  }
};

var renderMap = function(map) {
  if (map.show instanceof Function) {
    map.show();
  }
};

renderMap(googleMap);
renderMap(baiduMap);
```

### 封装

封装的目的是将信息隐藏。

1. 封装数据

利用闭包实现数据封装。

```js
var myObject = (function() {
  var _name = 'sven';
  return {
    getName: function() {
      return _name;
    }
  };
})();

console.log(myObject.getName()); // sven
console.log(myObject._name); // undefined
```

2. 封装实现

封装使得对象之间的耦合变得松散，对象之间只通过暴露的api接口来通信。当我们修改一个对象时，可以随意的修改功能，只要对外的接口没有变化就不会影响到程序的其他功能。

### 原型编程的基本原则

1. 所有的数据都是对象
2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它
3. 对象会记住它自己的原型
4. 如果对象无法相应某个请求，它会把这个请求委托给它自己的原型

### 两种创建对象的方式的比较

1. 在当前的javascript引擎下，通过Object.create来创建对象的效率并不高，通常比通过构造函数创建的对象要慢；
2. 通过设置构造器的prototype来实现原型继承的时候，除了根对象Object.prototype本身之外，任何对象都会有一个原型。而通过Object.create(null)可以创建出没有原型的对象。

## 第2章

### this

下面的这样简写会报错：

```js
var getId = document.getElementById;
getId('div1');
```
因为多数浏览器引擎的`document.getElementById`方法的内部实现中需要用到`this`，这个`this`需要指向`document`。当`getElementById`方法作为`document`对象的属性被调用的时候，方法内部的`this`确实是指向`document`的。但是，当用`getId`来引用`document.getElementByid`之后，再调用`getId`时，就成了普通函数的调用，函数内部的`this`指向了`window`，而不是原来的`document`。

解决办法：

```js
document.getElementById = (function(func) {
  return funtcion() {
    return func.apply(document.argument);
  }
})(document.getElementById);

var getId = Document.getElementById;
var div = getId('div1');
```

或者

```js
document.getElementById = document.getElementById.bind(document);
```

### call和apply

能熟练运用这两个方法，是我们真正成为一名javascript程序员的重要一步。

当使用call或者apply的时候，如果我们传入的第一个参数是null，函数体内的this会指向默认的宿主对象，在浏览器中则是window。

如果在严格模式下，函数体内的this还是为null。

有时候我们使用call、
或者apply的目的在于接通其他兑现的方法，那么我们可以传入null来代替某个具体的对象：

```js
math.max.apply(null, [1, 2, 3, 4, 5]);
```

**用途**

1. 改变this的指向
2. Function.prototype.bind

手动实现一个增强版的`bind`方法：

```js
Function.prototype.bind = function() {
  var self = this, // 此处会保存原函数，是调用bind的函数
      context = [].shift.call(arguments), // 获取第一个参数，即需要绑定的上下文
      args = [].slice.call(arguments); // 上面的shift会改变arguments，剩余的参数组成数组
  
  return function() {
    return self.apply(context, [].concat.call(args, [].slice.call(arguments)));
  };
};

var obj = {
  name: 'sven'
};

var func = function(a, b, c, d) {
  alert(this.name);
  alert([a, b, c, d]);
}.bind(obj, 1, 2);
func(3, 4);
```

3. 借用其他对象的方法

    1. 借用构造函数

        ```js
          var A = function(name) {
            this.name = name;
          };

          var B = function() {
            A.apply(this, arguments);
          }

          B.prototype.getName = function() {
            return this.name;
          }

          var b = new B('sven');
          console.log(b.getName()); // sven
        ```
    
    2. 借用数组的方法操纵类数组

      **借用数组的方法需要满足下面两个条件：**

      1. 对象本身要可以存取属性；（数值类型就不可以）
      2. 对象的`length`属性可以读写。（函数的length属性是传入的形参的个数，就是个只读属性，所以函数就无法借用数组的方法）。

      ```js
      (function() {
        Array.prototype.push.call(arguments, 3);
        console.log(arguments);
      })(1, 2);
      ```

      - 把arguments转成真正的数组时，借用`Array.prototype.slice`;
      - 截取arguments列表中的头一个元素，借用`Array.prototype.shift`;
      - 向arguments中插入一个新的元素时，借用`Array.prototype.push`。

      V8引擎关于`Array.prototype.push`的实现：
      ```js
      function ArrayPush() {
        var n = To_UNIT32(this.length); // 被push的对象的length

        var m = %_ArgumentsLength(); // push 的参数个数

        for (var i = 0; i < m; i++) {
          this[i + n] = %_Arguments(i); // 复制元素,对象本身可以存取属性


        }
        this.length = n + m ; // 修正length属性的值，对象的length属性可以读写

        return this.length;
      }
      ```

      下面这段代码改变了我对对象的认识，它竟然能在chrome中执行！！！明明对象没有`length`属性，但是对普通对象调用`Array.prototype.push`方法就会对这个对象添加一个`length`属性，并按序号添加键值对，俨然就是一个类数组。

      ```js
      var a = {};
      Array.prototype.push.call(a, 'first');
      console.log(a); // {0: 'first', length: 1}
      ```

## 第3章

### 闭包

1. 封装变量&提炼函数

**如果在一个大函数中有一些代码块能够独立出来，我们常常会把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也能起到注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把它们用闭包封闭起来。**

```js
var mult = (function() {
  var cache = {};
  var calculate = function() {
    var a = 1;
    for (var i = 0; l = arguments.length; i < l; i++) {
      a = a * arguments[i];
    }
    return a;
  };

  return function() {
    var args = Array.prototype.join.call(arguments, ',');
    if (args in cache) {
      return cache[args];
    }
    return cache[args] = calculate.apply(null, arguments);
  };
})();

mult(1, 2, 3);
```

上面这段代码，有两个地方是自己平时不会这样写的，走势在最后一行：

  1. `return cache[args] = calculate.apply(null, arguments)`返回值在此处李永乐赋值表达式的返回结果；
  2. `calculate.apply(null, arguments)`中`calculate`的调用使用了`apply`，如果用普通的函数传参调用会导致上面`calculate`函数中的`arguments.length=1`。所以要使用`apply`调用。

2. 延续局部变量的寿命

### 闭包和面向对象的设计

对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。**通常用面向对象思想能实现的功能，用闭包也能实现。**卧槽！从没想过闭包的地位竟然这么高！！！！！

使用闭包实现一段代码：

```js
var extent = function() {
  var value = 0;
  return {
    call: function() {
      value++;
      console.log(value);
    }
  };
};

var extent = extent();
extent.call();
extent.call();
extent.call();
```

使用面向对象实现相同的结果：

```js
var extent = {
  value: 0,
  call: function() {
    this.value++;
    console.log(this.value);
  }
};
extent.call();
extent.call();
extent.call();

// 或者

var Extent = function() {
  this.value = 0;
};

Extent.prototype.call = function() {
  this.value++;
  console.log(this.value);
};

var extent = new Extent;
extent.call();
extent.call();
extent.call();
```

### 闭包与内存管理

如果将来要回收这些变量，可以手动把这些变量设为null。

循环引用导致了内存泄露，为了解决这个问题，只需要把循环引用中的变量设为null即可。

### 高阶函数-函数作为参数

**把函数作为参数传递，把一部分容易变化的业务逻辑抽离出来，放在函数参数中，这样以来可以分离业务代码中变化与不变的部分。** —— 另一种实现代码分离的方法，之前说过的多态可以做到这点。

1. 回调函数
2. Array.prototype.sort

### 高阶函数-函数作为返回值输出

1. 单例模式

```js
var getSingle = function(fn) {
  var ret;
  return function() {
    return ret || (ret = fn.apply(this, arguments));
  };
};

var getScript = getSingle(function() {
  return document.createElement('script');
});

var script1 = getScript();
var script2 = getScript();

console.log(script1 === script2);
```

2. 函数currying

**`currying`又称`部分求值`**。一个currying的函数首先会接受一些参数，接受了这些参数后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。

比如下面的例子：

```js
var currying = function(fn) {
  var args = [];
  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args);
    } else {
      [].push.apply(args, arguments);
      return arguments.callee // 这个callee不再推荐使用了
    }
  }
};

var cost = (function() {
  var money = 0;
  return function() {
    for (var i =0, l =arguments.length; i < l; i++) {
      money += arguments[i];
    }
  }
})();

var cost = currying(cost);

cost(100); // 未真正求值
cost(200); // 未真正求值
cost(300); // 未真正求值

console.log(cost()); // 求值并输出结果
```