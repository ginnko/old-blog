---
layout: post
title: 《javascript设计模式》5-9章总结
date: 2018-08-26
tag: javascript
---

5-9章策略模式、代理模式、迭代器模式、发布-订阅模式以及命令模式

## 第5章 策略模式

- 策略模式：定义一系列算法，把它们一个个的封装起来，并且使它们可以互相替换。

策略模式的优点：

1. 策略模式利用组合、委托和多台等技术和思想，可以有效地避免多重条件选择语句;
2. 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，易于理解，易于扩展;
3. 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作;
4. 在策略模式中利用组合和委托来让context拥有执行算法的能力，这也是继承的一种更轻便的替代方法。

- 策略模式的缺点：

1. 使用策略模式会在程序中增加许多策略类或者策略对象，实际上这比把它们负责的逻辑堆砌在Context中要好;
2. 要使用策略模式，必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy。此时strategy要向客户暴露它的所有实现，这是违反最少知识原则的。


下面这段代码：

```js
var calculateBonus = function(oerformanceLevel, salary) {
  if (performanceLevel === 'S') {
    return salary * 4;
  }
  if (performanceLevel === 'A') {
    return salary * 3;
  }
  if (performanceLevel === 'B') {
    return salary * 2;
  }
};
```

书中说这种写法有三个缺点：

- calculateBonus函数比较庞大，包含了很多if-else语句，这些语句需要覆盖所有的逻辑分支;

- calculateBonus函数缺乏弹性，如果增加了一种新的绩效等级，或者想把绩效S的奖金系数ailie5,就必须深入calculateBonus函数的内部实现，这是违反 **开放-封闭原则**的。

- 算法的复用性差，如果在程序的其他地方需要重用这些计算奖金的算法，就只有选择复制和粘贴代码。

**策略模式的目的**：就是将算法的使用和算法的实现分离开来。

一个基于策略模式的程序至少由两部分组成：

1. 第一部分是一组策略类，策略类了封装了具体的算法，并负责具体的计算过程;

2. 第二部分是环境类，环境类接受客户的请求，随后把请求委托给某一个策略类。 **要做到这一点，说明环境类中要维持对某个策略对象的引用。**

### 重构第一版代码（模仿传统面向对象语言中的实现）：

```js
//把每种绩效的计算规则都封装在对应的策略类中

var performanceS = function() {};

performanceS.prototype.calculate = function(salary) {
  return salary * 4;
};

var performanceA = function() {};

performanceA.prototype.calculate = function(salary) {
  return salary * 3;
}

var performanceB = function() {};

performanceB.prototype.calculate = function(salary) {
  return salary * 2;
}

//定义奖金类Bonus

var Bonus = function() {
  this.salary = null;
  this.strategy = null;
};

Bonus.prototype.setSalary = function(salary) {
  this.salary = salary;
};

Bonus.prototype.setStrategy = function(strategy) {
  this.strategy = strategy;
};

Bonus.prototype.getBonus = function() {
  return this.strategy.calculate(this.salary);
}

//创建一个bonus对象，给bonus对象设置一些原始数据，然后把某个奖金的策略对象也传入bonus对象内部保存起来。当调用bonus.getBonus()来计算奖金的时候，bonus对象本身并没有能力进行计算，而是把请求委托给了之前保存好的策略对象。

var bonus = new Bonus();

bonus.setSalary(10000);
bonus.setStrategy(new performanceS());

console.log(bonus.getBonus());

bonus.setStrategy(new performanceA());

console.log(bonus.getBonus());
```

### 第二版 javascript版本的策略模式

```js
//策略对象

var strategies = {
  S: function(salary) {
    return salary * 4;
  },
  A: function(salary) {
    return salary * 3;
  },
  B: function(salary) {
    return salary * 2;
  }
};

//环境对象

var calculateBonus = function(level, salary) {
  return strategy[level](salary);
};

console.log('S', 20000); // 80000
console.log('A', 10000); // 30000
```

### 使用策略模式实现缓动动画

```js
// 常用缓动动画算法
var tween = {
  linear: function(t, b, c, d) {
    return c * t / d + b;
  },
  easeIn: function(t, b, c, d) {
    return c * (t / b) * t + b;
  },
  strongEaseIn: function(t, b, c, d) {
    return c * (t /= d) * t * t * t * t +b;
  },
  strongEaseOut: function(t, b, c, d) {
    return c * ( ( t = t / d - 1) * t * t * t * t + 1 ) + b;
  },
  sineaseIn: function( t, b, c, d ){
  return c * ( t /= d) * t * t + b;
  },
  sineaseOut: function(t,b,c,d){
  return c * ( ( t = t / d - 1) * t * t + 1 ) + b;
  }
};

//Animate类，这个构造函数接受一个参数，即将运动起来的dom节点
var Animate = function(dom) {
  this.dom = dom;
  this.startTime = 0;
  this.startPos = 0;
  this.endPos = 0;
  this.propertyName = null;
  this.easing = null;
  this.duration = null;
};

//Animate.prototype.start负责启动这个动画，在动画被启动的瞬间，要记录一些信息，供换动算法在以后计算小球当前位置的时候使用。在记录完这些信息之后，次方法还要负责启动定时器。
Animate.prototype.start = function(propertyName, endPos, duration, easing) {
  this.startTime = +new Date;
  this.startPos = this.dom.getBoundingClientRect()[propertyName];
  this.propertyName = propertyName;
  this.endPos = endPos;
  this.duration = duration;
  this.easing = tween[easing];

  var self = this;
  var timeId = setInterval(function() {
    if (self.step === false) {
      clearInterval(timeId);
    }
  }, 19);
};

// 下面这个方法定义了小球运动每一帧要做的事情，具体讲就是负责计算小球的当前位置和调用更新css属性值的方法
Animate.prototype.step = function() {
  var t = +new Date;
  if (t >= this.startTime + this.duration) {
    this.update(this.endPos);
    return false;
  }
  var pos = this.easing(t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration);
  this.update(pos);
};

// 更新小球css属性值的Animate.prototype.update方法
Animate.prototype.update = function(pos) {
  this.dom.style[this.propertyName] = pos + 'px';
};
```

### 利用策略类进行表单验证

```js
// 封装校验规则
var strategies = {
  isNonEmpty: function(value, errorMsg) {
    if (value === '' ) {
      return errorMsg;
    }
  },
  minLength: function(value, length, errorMsg) {
    if (value.length < length) {
      return errorMsg;
    }
  },
  isMobile: function(value, errorMsg) {
    if (!/^1[3|5|8][0-9]{9}$/.test(value)) {
      return errorMsg;
    }
  }
};

// 环境类
var Validator = function() {
  this.cache = [];
};

Validator.prototype.add = function(dom, rule, errorMsg) {
  var ary = rule.split(':');
  // 感觉下面这一顿操作神厉害
  // 把参数按正确的顺序组成一个数组，然后使用apply进行调用
  // 666
  this.cache.push(function() {
    var strategy = ary.shift();
    ary.unshift(dom.value);
    ary.push(errorMsg);
    return strategies[strategy].apply(dom, ary);
  });
};

Validator.prototype.start = function() {
  for (var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) {
    var msg = validatorFunc();
    if (msg) {
      return msg;
    }
  }
};

var validateFunc = function() {
  var validator = new Validator();

  // 添加校验规则
  // validator.add 第二个参数很有意思诶
  // 冒号前面的 minLength 代表客户挑选的 strategy对象,冒号后面的数字 6 表示在校验过程中所必需的一些参数。 'minLength:6' 的意思就是校验 registerForm.password 这个文本输入框的 value 最小长度为 6。如果这个字符串中不包含冒号,说明校验过程中不需要额外的参数信息,比如 'isNonEmpty' 。

  // 从没有想过要这样使用诶
  // 自己写的话肯定将那个6也作为一个单独的参数了
  validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空');
  validator.add(registerForm.password, 'minLength:6', '密码长度不能少于6位');
  validator.add(registerForm.phoneNumber, 'isMobile', '手机号码个是不正确');

  var errorMsg = validator.start();
  return errorMsg;
};
```

### 一等函数与策略类模式

**在javascript语言的策略模式中，策略类往往被函数所代替，这时策略模式就成为一种“隐形”的模式。**下面的代码去掉了strategies这个名字，但依然是策略模式的实现：

```js
var S = function(salary) {
  return salary * 4;
};

var A = function(salary) {
  return salary * 3;
};

var B = function(salary) {
  return salary * 2;
};

var calculateBonus = function(func, salary) {
  return func(salary);
};

calculateBonus(S, 10000);
```